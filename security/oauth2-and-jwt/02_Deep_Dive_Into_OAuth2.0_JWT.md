# Deep Dive Into OAuth2.0 and JWT (02. OAuth2.0)

이전에 우리는 인증과 인가(권한 부여)에 대해 소개했습니다. 이번 글에서는 가장 일반적으로 사용되는 구현 중 하나인 OAuth2.0에 대해 살펴보겠습니다.



### 소개

기존 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명(credential)을 사용하여 서버에 인증하여 서버에서 보호된 리소스를 요청합니다. 제한된 리소스에 대한 써드파티 앱의 액세스를 제공하기 위해 리소스 소유자는 해당 자격 증명을 타사와 공유합니다. 이러한 자격 증명 공유는 몇 가지 문제와 제한 사항을 유발할 수 있으며 그 중 일부는 아래에 나열되어 있습니다.

- 써드파티 앱은 나중에 사용하기 위해 리소스 소유자의 인증 정보(일반적으로 암호)를 일반 텍스트로 저장해야 합니다.
- 서버는 비밀번호에 내재된 보안 취약점에도 불구하고 비밀번호 인증확인을 지원해야 합니다.
- 써드파티 앱은 리소스 소유자의 보호된 리소스에 지나치게 광범위하게 액세스하므로 리소스 소유자는 제한된 리소스 하위 집합에 대한 액세스나 기간을 제한할 수 없습니다.
- 리소스 소유자는 모든 타사 액세스 권한을 취소하지 않고는 개별 써드파티 앱의 액세스 권한을 취소할 수 없으며 써드파티 앱의 암호를 변경하여 취소해야 합니다.



OAuth는 인증 레이어를 도입하고 리소스 소유자의 역할과 클라이언트의 역할을 분리하여 이러한 문제를 해결합니다. 

> OAuth는 인증 프로토콜로, 사용자가 **자격 증명을 노출할 필요 없이 한 사이트, 다른 사이트에 있는 리소스에 제한된 액세스 권한을 부여**할 수 있습니다.

OAuth는 리소스 소유자를 대신하여 서버 리소스에 대한 "보안 위임 액세스"를 클라이언트에 제공합니다. 리소스 소유자가 인증 정보를 공유하지 않고 서버 리소스에 대한 타사 액세스를 허가하는 프로세스를 지정합니다. 

예를 들어보죠.

발렛 키가 있는 차들이 있다는 것을 알고 있나요? 아직 모르신다면, 주차요원에게 주는 특별한 종류의 열쇠가 딸려있는 차들이 있습니다. 당신의 일반 열쇠와 달리, 이 열쇠는 차가 1~2마일 이상 주행할 수 없게 합니다. (오 이런게 있었나요?)

일부 발렛 키는 트렁크를 열지 않는 반면, 다른 키는 탑승한 휴대폰 주소록에 대한 액세스를 차단합니다. 발렛 키가 어떤 제한을 가하는지와 상관없이, 그 아이디어는 매우 영리합니다. 일반 키를 사용하여 모든 것을 잠금 해제하는 동안 특수 키를 사용하여 다른 사람에게 제한적으로 차에 접근할 수 있습니다.

마찬가지로, OAuth에서는 발렛 키 대신 액세스 토큰을 사용하여 서로 다른 수준의 리소스 액세스를 허용합니다.



### OAuth2.0 용어

**Role**: OAuth2.0 스펙에는 네 가지 롤(역할)이 정의되어 있습니다.

1. **Resource Owner**: 보호된 리소스에 대한 액세스 권한을 부여할 수 있는 엔티티입니다. 이 엔티티가 사람인 경우 최종 사용자라고 합니다.
2. **Resource Server**: 보호된 리소스를 호스팅하는 서버로서 액세스 토큰을 사용하여 보호된 리소스에 대한 요청을 수락하고 응답할 수 있습니다.
3. **Client**: 리소스 소유자를 대신하여 해당 권한을 부여하여 보호된 리소스를 요청하는 응용 프로그램입니다. "클라이언트"라는 용어는 구현 특성(예: 응용프로그램이 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.
4. **Authorization Server**: 리소스 소유자를 인증하고 권한을 얻은 후 서버에서 클라이언트에 액세스 토큰을 발급합니다.



**Token**: 두 가지 타입의 토큰이 있습니다.

1. **Access Token**: 액세스 토큰은 클라이언트에 발급된 권한을 나타내는 문자열입니다. 일반적으로 문자열은 클라이언트에 이해하기 어렵게 되어있습니다. 토큰은 특정 `scope(권한 범위)` 및 액세스 기간을 나타내며 리소스 소유자가 부여하고 리소스 서버 및 권한 부여 서버에서 실행합니다.

   토큰은 인증 정보를 검색하는 데 사용되는 식별자를 나타내거나 인증 정보를 확인 가능한 방법(예: 일부 데이터와 서명으로 구성된 토큰 문자열)으로 자체 포함할 수 있습니다.

2. **Refresh Token**: 액세스 토큰을 얻는 데 사용되는 자격 증명입니다. 리프레시 토큰은 권한 부여 서버에 의해 클라이언트에 발급되며 현재 액세스 토큰이 유효하지 않거나 만료될 때 새 액세스 토큰을 얻거나 동일하거나 범위가 좁은 추가 액세스 토큰을 얻는 데 사용됩니다(액세스 토큰의 수명이 리소스 소유자가 허가한 것보다 짧고 사용 권한이 적을 수 있음).

   리프레시 토큰 발행은 권한 부여 서버의 재량에 따라 선택 사항입니다. 인증 서버가 리프레시 토큰을 발급하면 액세스 토큰을 발급할 때 포함됩니다.

액세스 토큰과 달리 리프레시 토큰은 권한 부여 서버에만 사용되며 리소스 서버에는 전송되지 않습니다.

**권한 부여**: 권한 부여는 액세스 토큰을 얻기 위해 클라이언트가 사용하는 리소스 소유자의 권한 부여(보호된 리소스에 액세스하기 위해)를 나타내는 자격 증명입니다. 

OAuth2.0 사양은 4가지 부여 유형을 정의합니다.

1. **Authorization Code:** 인가 코드는 인가 서버를 클라이언트와 리소스 소유자 간의 중개자로 사용하여 얻습니다. 리소스 소유자에게 직접 권한 부여를 요청하는 대신 클라이언트는 리소스 소유자를 권한 부여 서버로 안내하고, 리소스 소유자는 다시 권한 부여 코드를 사용하여 클라이언트로 안내합니다.
2. **Implicit Grant:** 클라이언트에게 인증 코드를 발행하는 대신 클라이언트가 직접 액세스 토큰을 발행합니다.
3. **Resource owner password credentials (ROPC):** 리소스 소유자 암호 자격 증명(즉, 사용자 이름 및 암호)은 액세스 토큰을 얻기 위한 권한 부여로 직접 사용할 수 있습니다. ROPC는 리소스 소유자와 클라이언트 사이에 높은 수준의 신뢰가 있고(예: 클라이언트가 장치 운영 체제의 일부이거나 높은 권한이 있는 응용 프로그램) 다른 권한 부여 유형을 사용할 수 없는 경우(예: 인증 코드로).
4. **Client Credentials:** 클라이언트 자격 증명(또는 다른 형태의 클라이언트 인증)은 권한 부여 범위가 클라이언트의 제어 하에 있는 보호된 리소스 또는 권한 부여 서버와 함께 이전에 정렬된 보호된 리소스로 제한되는 경우 권한 부여 부여로 사용할 수 있습니다. 클라이언트 자격 증명은 일반적으로 클라이언트가 자체적으로 작업을 수행하거나(클라이언트가 리소스 소유자이기도 함) 권한 부여 서버와 이전에 정렬된 권한 부여를 기반으로 보호된 리소스에 대한 액세스를 요청할 때 권한 부여 부여로 사용됩니다.

OAuth2.0으로 작업하는 동안 이러한 용어를 이해하는 것이 매우 중요합니다. 따라서 예를 들어 이러한 내용을 이해하려고 합니다.

![OAuth analogy to metro train ](https://dz2cdn1.dzone.com/storage/temp/12451954-oauth-flow.png)

지하철 철도 운송 시스템을 생각해 보십시오. 온보딩 흐름은 일반적으로 다음과 같이 진행됩니다. 

1. 통근자가 자동 판매기 또는 티켓 판매업체에 티켓/토큰을 요청합니다. 
2. 티켓 판매업체/기계는 제한된 기간 및/또는 스테이션 수에 대해 유효한 토큰/티켓을 부여합니다. 
3. 통근자는 이 토큰을 게이트에 액세스하기 위해 제시합니다. 
4. 토큰이 유효하면 출입 게이트를 통해 입장이 가능하며 통근자는 기차에 탑승할 수 있습니다.



위의 시나리오는 OAuth2.0에서 다음 역할에 매핑될 수 있습니다.

![OAuth analogy to metro train](https://dz2cdn1.dzone.com/storage/temp/12451955-oauth-mapping.png)

1. **클라이언트**(통근자)는 **보호된 리소스**(지하철)를 사용하기 위해 **리소스 서버**(티켓 판매업체)에 티켓을 요청합니다.
2. **인가 서버**(티켓 판매업체)는 **리소스 소유자**(지하철 기관)를 대신하여 **토큰**(티켓)에 액세스 권한을 부여합니다.
3. **클라이언트**(통근자)는 이 **토큰**(티켓)을 액세스하기 위해 포함하여 요청합니다.
4. 토큰이 유효하면 **리소스**(지하철 탑승)를 제공합니다.



### OAuth2.0 제어 흐름

![OAuth2.0 control flow](https://dz2cdn1.dzone.com/storage/temp/12451958-control-flow.png)



### 사용 사례

OAuth2.0은 인가 정책 결정에서 인증을 분리합니다. 적절하게 설계된 OAuth2.0 토큰은 세분화된 승인과 대략적인 승인을 모두 활성화할 수 있습니다. 한 장소에 저장된 리소스/데이터를 다른 장소(서버/애플리케이션)에서 액세스하려는 모든 시나리오에서 OAuth2.0이 가장 적합할 수 있습니다.

피트니스 웨어러블 밴드를 예로 들어보겠습니다.

Alice가 피트니스 밴드를 구입하고 밴드 제공자의 모바일 앱을 사용하여 진행 상황을 추적하고 분석한다고 가정해 보겠습니다. 그러면 그 흐름은 어떻게 될까요?

1. 먼저 Alice는 모바일 앱에서 프로필을 만들어야 합니다. 앱이 프로필 생성 양식을 제공할 수 있고 Alice가 이를 사용하여 프로필을 생성하거나 앱이 Alice가 이미 데이터를 저장한 다른 앱에서 프로필 데이터에 액세스하고 가져올 수 있습니다. 확실히 실제 소셜 미디어 사이트가 아닌 FriendBook이라고 가정해 보겠습니다.
2. 해당 앱은 FriendBook의 로그인으로 리디렉션됩니다. Alice가 자격 증명을 사용하여 성공적으로 로그인하면 공유하려는 정보와 FriendBook에 저장할 수 있는 액세스 권한을 허용/검증하는 동의 페이지가 표시됩니다. 확인 후 앱은 OAuth2.0을 사용하여 FriendBook에서 데이터를 가져와 사용할 수 있습니다.
3. 웨어러블 장치는 데이터를 앱으로 보내고 앱은 기록 및 분석 목적으로 서버와 데이터를 동기화합니다.

**Client Password**: (OAuth2.0을 사용한 인증은 피해야 합니다). Alice는 새 암호를 만들 필요가 없었습니다. 대신 그녀는 이미 만든 비밀번호와 FriendBook 서버를 사용했습니다.

**Web Server**: 웨어러블 밴드용 앱은 매번 로그인을 요청할 필요가 없었습니다. Alice는 FriendBook과 데이터를 공유하거나 FriendBook에서 데이터를 가져오기를 원합니다. 앱은 서버 간 인증을 통해 데이터에 액세스할 수 있습니다.

**User-Agent**: 앱이 중앙 서버와 데이터를 동기화하는 앱 서버의 에이전트로 실행 중입니다. 이 에이전트는 OAuth2.0을 사용하여 권한을 부여하므로 서버(데이터)의 리소스에 완벽하게 액세스할 수 있습니다.

다음 글에서는 다른 토큰 기반 구현, 즉 JWT를 살펴보겠습니다.



## 참고

- [DZone 기사](https://dzone.com/articles/deep-dive-to-oauth20-amp-jwt-part-2-oauth20)

